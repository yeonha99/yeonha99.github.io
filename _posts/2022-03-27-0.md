---

layout: single
title:  "자바 ORM 표준 JPA 프로그래밍 -기본편"
categories: WEB
tags: [JPA,ORM]
toc: true
author_profile: false
---

# 자바 ORM 표준 JPA 프로그래밍 -기본편

JPA : 자바 진영의 ORM 기술

ORM : 객체 관계 매핑

JPA를 쓰면 패러다임 불일치 해결, 통신은 JDBC API 사용

JPA 왜 써야하는 가

- 생산성 좋아짐
- 유지보수에 좋다.
- 패러다임 불일치 해결
- 동일한 트랜잭션에서 조회한 엔티티는 같다.

JPA의 성능 최적화 기능

1. 1차 캐시와 동일성 보장
    1. DB Isolation Level이 Read Commit이어도 애플리케이션에서 Repeatable Read 보장
2. 트랜잭션을 지원하는 쓰기 지연
    1. transaction.begin(), transaction.commit(); 으로 한번에 보내기 가능 (jdbc Bach 사용)
3. 지연로딩과 즉시로딩
    1. 지연 로딩: 객체가 실제 사용될 때 로딩
    2.  즉시 로딩: JOIN SQL로 한번에 연관된 객체까지 미리 조회
    

영속성 컨텍스트

- 엔티티를 영구 저장하는 환경이라는 뜻
- 엔티티 매니저를 통해서 영속성 컨텍스트에 접근한다.

엔티티의 생명주기

- 비영속:객체를 생성한 상태 (생성만 함)
- 영속:객체를 저장한 상태 em.persist()
- 준영속:영속성 컨텍스트에서 없애는 것
- 삭제: 실제 DB 삭제 뜻함

영속성 컨텍스트의 이점

- 1차 캐시
- 동일성 보장
- 트랜잭션을 지원하는 쓰기 지연
- 변경 감지
- 지연 로딩

플러시

- 영속성 컨텍스트의 변경내용을 데이터베이스에 반영
- 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화
- 트랜잭션이라는 작업 단위 중요 → 커밋 직전에만 동기화하면 됨

준영속 상태

- 영속 → 준영속
- em.detach(); 특정 그것만 초기화
- em.clear(); 모두 초기화
- em.close() 영속성 컨텍스트 종료

@Entity가 붙은 클래스는 JPA가 관리 엔티티라 한다.

JPA를 사용해서 테이블과 매핑할 클래스는 필수

주의

- 기본 생성자 필수(파라미터가 없는 public 또는 Protected 생성자)
- final 클래스, enum,interface,inner 클래스 사용 X
- 저장할 필드에 final 사용 X

@Column(unique= true, length=10) 이런거 가능

@Enumerated(EnumType.STRING) //ORDINAL는 순서를 DB에 저장

@Temporal(TemporalType.TIME)

그런데 자바 8이상부터는 LocalDate, LocalDateTime로 사용 가능

@Lob 엄청 많은 Varchar

@Transient 특정 컬럼을 DB에 상관없이 사용 희망

nullable 널 허용 의미

insertable, updatable 등록,변경 가능 여부

기본 키 매핑 방법

직접 할당 : @Id 사용

자동 생성: @GeneratedValue

- IDENTITY
- SEQUENCE

@ManyToOne

@OneToMany

- mappedBy:어떤 것에 매핑 당했다.

@JoinColume

연관관계의 주인

-양방향 매핑 규칙

- 객체의 두 관계중 하나를 연관관계의 주인으로 지정
- 연관관계의 주인만이 외래 키를 관리
- 주인이 아닌쪽은 읽기만 가능
- 주인은 mappedBy 속성 사용 X
- 주인이 아니면 mappedBy 속성으로 주인 지정

-누구를 주인으로?

- 외래 키가 있는 곳을 주인으로 정해라

연관관계 매핑시 고려사항

- 다중성
- 단방향, 양방향
- 연관관계의 주인

다중성

- 다대일 : ManyToOne
- 일대다 : OneToMany
- 일대일 : OneToOne
- 다대다: ManyToMany

테이블은 외래 키 하나로 양쪽 조인이 가능하고 방향이라는 개념이 없지만 객체는 참조용 필드가 있는 쪽으로만 참조가 가능하고 한쪽만 참조하면 단방향이고 양쪽이 서로 참조하면 양방향이라고 한다.

일대다 단방향 매핑의 단점

- 엔티티가 관리하는 외래 키가 다른 테이블에 있다.
- 연관관계 관리를 위해 추가로 업데이트 sql 실행
- 일다다 단방향 매핑보다는 다대일 양방향 매팅 사용 추천

일대일 관계

- 주테이블이나 대상 테이블 중에 외래 키 선택 가능
- 외래키에 데이터베이스 유니크 추가 필요

상속관계 매핑 방법

조인 전략, 단일 테이블 전략, 구현 클래스마다 테이블 전략

(부모 클래스 추상화 필요)

조인 전략 선택 시

- 부모 클래스에서 @Inheritance(strategy = InheritanceType.JOINED)
- DiscriminatorColumn(name="role") 부모 클래스에서 설정 가능
- DiscriminatorValue로 자식 클래스에서 설정 가능

조인 전략

- 장점
    - 테이블 정규화
    - 외래 키 참조 무결성 제약조건 활용가능
    - 저장공간 효율화
- 단점
    - 조회시 조인을 많이 사용, 성능 저하
    - 조회 커리가 복잡함
    - 데이터 저장시 INSERT SQL 2번 호출

단일 테이블 전략

- 장점
    - 조인이 필요 없으므로 일반적으로 조회 성능이 빠름
    - 조회 쿼리가 단순함
- 단점
    - 자식 엔티티가 매핑한 컬럼은 모두 null 허용
    - 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있고 상황에 따라서 조회 성능이 오히려 느려질 수 있다.

구현 클래스마다 테이블 전략

- 조회시 각 테이블을 모두 검색해야함

@MappedSuperclass

- 공통 매핑 정보가 필요할 때 사용(id,name)
- 상속관계 매핑 x
- 엔티티X, 테이블과 매핑X
- 부모 클래스를 상속 받는 자식 클래스에 매핑 정보만 제공
- 조회, 검색 불가
- 직접 생성해서 사용할 일이 없으므로 추상 클래스 권장

프록시 기초

- em.find() vs em.getReference()
- em.find()는 DB에 직접 조회
- em.getReference() 를 호출하는 시점에는 쿼리가 안나가고 실제로 필요할때 쿼리가 나간다. 가짜 엔티티 객체를 조회하게 된다.

프록시 특징

- 실제 클래스를 상속 받아서 만들어짐
- 실제 클래스와 겉 모양이 같다.
- 사용하는 입장에서는 실제 객체인지 가짜 객체인지 구분하지 않고 사용가능
- 프록시 객체는 실제 객체의 참조를 보관한다.
- 프록시 객체는 처음 사용할 때 한 번만 초기화
- 프록시 객체를 초기화 할때 실제 엔티티로 바뀌는 것이 아니라 접근이 가능해 지는 것이다.
- 프록시 객체는 ==비교 대신 instance of 사용
- 영속성 컨텐스트에 찾는 엔티티가 이미 있으며 em.getReference()을 호출해도 원래 엔티티 가져와준다.
- 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제 발생

프록시 객체의 초기화

getName()하면 영속성 컨텐스트에 초기화를 요청하고 실제 DB를 조회해서 실제 엔티티가 생성되고 프록시 객체의 타겟에 지정하여서 리턴

지연로딩

- 지연 로딩을 하게 되면 프록시를 조회해 온다. 실제 사용할때 초기화가 된다.

즉시로딩

- EAGER
- 가져 올 때 한번에 진짜 엔티티를 모두 조인하여 가져온다.

프록시와 즉시로딩 주의

- 가급적 지연 로딩만 사용(특히 실무에서)
- 즉시 로딩을 적용하면 예상하지 못한 SQL이 발생
- 즉시 로딩은 JPQL에서 N+1 문제를 일으킨다.
    - 필요하지 않은 쿼리도 나가게 된다. 지연로딩,fetch 조인, 어노테이션 등으로 해결 가능하다.
- @ManyToOne, @OneToOne은 기본이 즉시로딩으로 설정

영속성 전이: CASCADE

- 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶을 때
- OneToMany(cascade=CascadeType.ALL)

고아 객체

- 고아 객체 제거:부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제
- orphanRemoval=true
- 참조하는 곳이 하나일 때 사용해야함
- 특정 엔티티가 개인 소유일 때 사용

영속성 전이와 orphanRemoval을 모두 활성화 하면 부모 엔티티를 통해서 자식의 생명 주기를 모두 관리할 수 있다.

기본값 타입

- 생명주기를 엔티티에 의존
- 값 타입은 공유하면 X
- integer같은 레퍼 클래스나 string 같은 특수한 클래스는 공유가능한 객체이지만 변경 X

임베디드 타입

- 새로운 값 타입을 직접 정의할 수 있다.
- 주로 기본 값 타입을 모아서 만든다.
- @Embeddable:값 타입을 정의하는 곳에 표시
- @Embedded: 값 타입을 사용하는 곳에 표시
- 기본 생성자 필수
- 컬럼명이 중복 될때는 @AttributeOverrrides({}) 사용

객체 타입의 한계

- 객체의 공유 참조는 피할 수 없다.
- 객체 타입은 참조 값을 직접 대입하는 것을 막을 방법이 없다.

불변 객체

- 생성 시점 이후 절대 값을 변경할 수 없는 객체
- 생성자로만 값을 설정하고 수정자를 만들지 않으면 됨

값 타입의 비교

- 동일성 비교: 인스턴스의 참조 값을 비교 == 사용
- 동등성 비교:인스턴스의 값을 비교 equals() 사용